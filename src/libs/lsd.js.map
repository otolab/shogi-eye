{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 836f7484e7a1bbd2de34","webpack:///lsd.js","webpack:///./src/lsd.ts","webpack:///./src/funcs.ts","webpack:///./src/types.ts"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","moduleId","installedModules","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","refineType","scale","sigmaScale","quant","angTh","logEps","densityTh","nBins","funcs","REFINE_NONE","width","height","list","detect","image","lsd","drawSegments","context","lines","color","strokeStyle","lineWidth","forEach","v","beginPath","moveTo","x1","y1","lineTo","x2","y2","stroke","closePath","putImageData","src","imageData","createImageData","dst","data","len","length","Error","angles","prec","Math","PI","rho","sin","sigma","h","ceil","sqrt","log","kSize","reshaped","reshape","gaussianBlur","computeLevelLineAngles","LOG_NT","log10","minRegSize","used","Uint8Array","listSize","point","at","NOT_USED","NOT_DEF","regAngle","reg","regionGrow","rect","Rect","region2Rect","refine","REFINE_ADV","improveRect","push","Vec4","threshold","Float64Array","modgrad","setRow","setCol","maxGrad","y","step","nextStep","x","DA","BC","gx","gy","norm","atan2","rangeS","rangeE","count","binCoef","floor","CoorList","next","Point","idx","start","endIdx","seed","RegionPoint","angle","USED","sumdx","cos","sumdy","rpoint","xxMin","max","xxMax","min","yyMin","yyMax","yy","xx","isUsed","isAligned","regionPoint","theta","a","nTheta","M_3_2_PI","M_2__PI","sum","pnt","weight","getTheta","dx","dy","lMin","lMax","wMin","wMax","regdx","regdy","w","ixx","iyy","ixy","regx","regy","doubleEqual","lambda","abs","angleDiff","density","dist","xc","yc","angC","sSum","angD","meanAngle","tau","reduceRegionRadius","radSq1","distSq","radSq2","radSq","tmp","pop","logNfa","rectNfa","r","copy","logNfaNew","delta","totalPts","algPts","halfWidth","dyhw","dxhw","orderedX","Edge","minY","maxY","sort","AsmallerB_XoverY","taken","leftmost","rightmost","tailp","flstep","slstep","frstep","srstep","lstep","rstep","leftX","rightX","minIter","maxIter","nfa","k","pTerm","log1Term","logGamma","term","exp","M_LN10","binTail","binTerm","multTerm","pow","ImageData","kernel","getGaussianKernel","tmp2","Uint8ClampedArray","buff","kx","px","j","ky","py","kStep","sigmaX","scale2X","row","rowIndex","subarray","index","from","to","default","LSD","logGammaLanczos","q","b","angleDiffSigned","diff","absDiff","aa","bb","absMax","MIN_VALUE","Number","RELATIVE_ERROR_FACTOR","EPSILON","DEG_TO_RADS","REFINE_STD","logGammaWindschitl","sinh"],"mappings":"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","file":"lsd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lineSegmentDetector\"] = factory();\n\telse\n\t\troot[\"lineSegmentDetector\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 836f7484e7a1bbd2de34","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lineSegmentDetector\"] = factory();\n\telse\n\t\troot[\"lineSegmentDetector\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Line Segment Detector (LSD) module\n * @author https://github.com/wellflat\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar funcs = __webpack_require__(1);\nvar types_1 = __webpack_require__(2);\n/**\n * Create a LineSegmentDetector object.\n * Specifying scale, number of subdivisions for the image,\n * should the lines be refined and other constants as follows:\n *\n * @param refine       How should the lines found be refined?\n *                      REFINE_NONE - No refinement applied.\n *                      REFINE_STD  - Standard refinement is applied. E.g. breaking arches into smaller line approximations.\n *                      REFINE_ADV  - Advanced refinement. Number of false alarms is calculated,\n *                                    lines are refined through increase of precision, decrement in size, etc.\n * @param scale        The scale of the image that will be used to find the lines. Range (0..1].\n * @param sigmaScale   Sigma for Gaussian filter is computed as sigma = _sigma_scale/_scale.\n * @param quant        Bound to the quantization error on the gradient norm.\n * @param angTh        Gradient angle tolerance in degrees.\n * @param logEps       Detection threshold: -log10(NFA) > _log_eps\n * @param densityTh    Minimal density of aligned region points in rectangle.\n * @param nBins        Number of bins in pseudo-ordering of gradient modulus.\n */\nvar LSD = /** @class */ (function () {\n    function LSD(refineType, scale, sigmaScale, quant, angTh, logEps, densityTh, nBins) {\n        if (refineType === void 0) { refineType = funcs.REFINE_NONE; }\n        if (scale === void 0) { scale = 0.8; }\n        if (sigmaScale === void 0) { sigmaScale = 0.6; }\n        if (quant === void 0) { quant = 2.0; }\n        if (angTh === void 0) { angTh = 22.5; }\n        if (logEps === void 0) { logEps = 0.0; }\n        if (densityTh === void 0) { densityTh = 0.7; }\n        if (nBins === void 0) { nBins = 1024; }\n        this.refineType = refineType;\n        this.scale = scale;\n        this.sigmaScale = sigmaScale;\n        this.quant = quant;\n        this.angTh = angTh;\n        this.logEps = logEps;\n        this.densityTh = densityTh;\n        this.nBins = nBins;\n        this.width = 0;\n        this.height = 0;\n        this.list = [];\n    }\n    /**\n     * Detect lines in the input image.\n     * @param {ImageData} image\n     * @return {Vec4[]}\n     */\n    LSD.prototype.detect = function (image) {\n        this.image = image;\n        this.width = image.width;\n        this.height = image.height;\n        var lines = this.lsd();\n        return lines;\n    };\n    /**\n     * Draws the line segments on a given image.\n     * @param {CanvasRenderingContext2D} context\n     * @param {Vec4[]} lines\n     * @param {string} color\n     */\n    LSD.prototype.drawSegments = function (context, lines, color) {\n        if (color === void 0) { color = '#ff0000'; }\n        context.strokeStyle = color;\n        context.lineWidth = 1;\n        lines.forEach(function (v) {\n            context.beginPath();\n            context.moveTo(v.x1, v.y1);\n            context.lineTo(v.x2, v.y2);\n            context.stroke();\n            context.closePath();\n        });\n    };\n    /**\n     * for debug\n     * @param {CanvasRenderingContext2D} context\n     */\n    LSD.prototype.putImageData = function (context) {\n        var src = this.imageData, image = context.createImageData(this.width, this.height), dst = image.data, len = image.data.length;\n        if (!src)\n            throw new Error('imageData required'); // type guard\n        for (var i = 0; i < len; i += 4) {\n            dst[i] = dst[i + 1] = dst[i + 2] = src[i / 4];\n            dst[i + 3] = 255;\n        }\n        context.putImageData(image, 0, 0);\n    };\n    /**\n     * @return {Vec4[]}  Return: A vector of Vec4f elements specifying the beginning and ending point of a line.\n     *                   Where Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end.\n     *                   Returned lines are strictly oriented depending on the gradient.\n     */\n    LSD.prototype.lsd = function () {\n        if (!this.image || !this.angles)\n            throw new Error('image and angles required'); // type guard\n        /** @type {Vec4[]} */\n        var lines = [];\n        var prec = Math.PI * this.angTh / 180;\n        var p = this.angTh / 180;\n        var rho = this.quant / Math.sin(prec);\n        if (this.scale != 1) {\n            var sigma = this.scale < 1 ? this.sigmaScale / this.scale : this.sigmaScale;\n            var sprec = 3;\n            var h = Math.ceil(sigma * Math.sqrt(2 * sprec * Math.log(10.0)));\n            var kSize = 1 + 2 * h;\n            var reshaped = this.reshape(this.image);\n            this.imageData = this.gaussianBlur(reshaped, kSize, sigma);\n            this.computeLevelLineAngles(rho, this.nBins);\n        }\n        else {\n            this.imageData = this.reshape(this.image);\n            this.computeLevelLineAngles(rho, this.nBins);\n        }\n        var LOG_NT = 5 * (Math.log10(this.width) + Math.log10(this.height)) / 2 + Math.log10(11.0);\n        var minRegSize = -LOG_NT / Math.log10(p);\n        this.used = new Uint8Array(this.imageData.length);\n        for (var i = 0, listSize = this.list.length; i < listSize; i++) {\n            var point = this.list[i].p;\n            if ((this.at(this.used, point) === funcs.NOT_USED) &&\n                (this.at(this.angles, point) !== funcs.NOT_DEF)) {\n                var regAngle = 0.0;\n                var reg = [];\n                regAngle = this.regionGrow(this.list[i].p, reg, regAngle, prec);\n                if (reg.length < minRegSize) {\n                    continue;\n                }\n                var rect = new types_1.Rect();\n                this.region2Rect(reg, regAngle, prec, p, rect);\n                var logNfa = -1;\n                if (this.refineType > funcs.REFINE_NONE) {\n                    if (!this.refine(reg, regAngle, prec, p, rect, this.densityTh)) {\n                        continue;\n                    }\n                    if (this.refineType >= funcs.REFINE_ADV) {\n                        logNfa = this.improveRect(rect);\n                        if (logNfa <= this.logEps) {\n                            continue;\n                        }\n                    }\n                }\n                rect.x1 += 0.5;\n                rect.y1 += 0.5;\n                rect.x2 += 0.5;\n                rect.y2 += 0.5;\n                /*\n                if (this.scale != 1) {\n                    rect.x1 /= this.scale;\n                    rect.y1 /= this.scale;\n                    rect.x2 /= this.scale;\n                    rect.y2 /= this.scale;\n                    rect.width /= this.scale;\n                }\n                */\n                lines.push(new types_1.Vec4(rect.x1, rect.y1, rect.x2, rect.y2));\n            }\n        }\n        return lines;\n    };\n    /**\n     * @param {number} threshold The minimum value of the angle that is considered defined, otherwise NOTDEF\n     * @param {number} nBins     The number of bins with which gradients are ordered by, using bucket sort.\n     */\n    LSD.prototype.computeLevelLineAngles = function (threshold, nBins) {\n        var imageData = this.imageData;\n        if (!imageData)\n            throw new Error('imageData required'); // type guard\n        var width = this.width;\n        var height = this.height;\n        this.angles = new Float64Array(imageData.length);\n        this.modgrad = new Float64Array(imageData.length);\n        this.angles = this.setRow(this.angles, height - 1, funcs.NOT_DEF);\n        this.angles = this.setCol(this.angles, width - 1, funcs.NOT_DEF);\n        var maxGrad = -1.0;\n        for (var y = 0; y < height - 1; y++) {\n            var step = y * width;\n            var nextStep = (y + 1) * width;\n            for (var x = 0; x < width - 1; x++) {\n                var DA = imageData[x + 1 + nextStep] - imageData[x + step];\n                var BC = imageData[x + 1 + step] - imageData[x + nextStep];\n                var gx = DA + BC;\n                var gy = DA - BC;\n                var norm = Math.sqrt((gx * gx + gy * gy) / 4.0);\n                this.modgrad[x + step] = norm;\n                if (norm <= threshold) {\n                    this.angles[x + step] = funcs.NOT_DEF;\n                }\n                else {\n                    this.angles[x + step] = Math.atan2(gx, -gy);\n                    if (norm > maxGrad) {\n                        maxGrad = norm;\n                    }\n                }\n            }\n        }\n        /** @type {CoorList[]} */\n        var rangeS = [];\n        rangeS.length = nBins;\n        /** @type {CoorList[]} */\n        var rangeE = [];\n        rangeE.length = nBins;\n        var count = 0;\n        var binCoef = (maxGrad > 0) ? (nBins - 1) / maxGrad : 0;\n        for (var y = 0; y < height - 1; y++) {\n            var step = y * width;\n            for (var x = 0; x < width - 1; x++) {\n                var i = Math.floor(this.modgrad[x + step] * binCoef);\n                if (!rangeE[i]) {\n                    this.list[count] = new types_1.CoorList();\n                    rangeE[i] = rangeS[i] = this.list[count];\n                    count++;\n                }\n                else {\n                    this.list[count] = new types_1.CoorList();\n                    rangeE[i] = this.list[count];\n                    rangeE[i].next = this.list[count];\n                    count++;\n                }\n                rangeE[i].p = new types_1.Point(x, y);\n                rangeE[i].next = null;\n            }\n        }\n        var idx = nBins - 1;\n        for (; idx > 0 && !rangeS[idx]; idx--) {\n            // do nothing.\n        }\n        var start = rangeS[idx];\n        var endIdx = idx;\n        if (start) {\n            while (idx > 0) {\n                idx--;\n                if (rangeS[idx]) {\n                    rangeE[endIdx].next = rangeS[idx];\n                    rangeE[endIdx] = rangeE[idx];\n                    endIdx = idx;\n                }\n            }\n        }\n    };\n    LSD.prototype.regionGrow = function (s, reg, regAngle, prec) {\n        if (!this.used || !this.angles || !this.modgrad)\n            throw new Error('used, angles and modgrad required'); // type guard\n        var seed = new types_1.RegionPoint();\n        seed.x = s.x;\n        seed.y = s.y;\n        seed.used = this.at(this.used, s);\n        regAngle = this.at(this.angles, s);\n        seed.angle = regAngle;\n        seed.modgrad = this.at(this.modgrad, s);\n        seed.used = funcs.USED;\n        reg.push(seed);\n        var sumdx = Math.cos(regAngle);\n        var sumdy = Math.sin(regAngle);\n        for (var i = 0; i < reg.length; i++) {\n            var rpoint = reg[i], xxMin = Math.max(rpoint.x - 1, 0), xxMax = Math.min(rpoint.x + 1, this.width - 1), yyMin = Math.max(rpoint.y - 1, 0), yyMax = Math.min(rpoint.y + 1, this.height - 1);\n            for (var yy = yyMin; yy <= yyMax; yy++) {\n                var step = yy * this.width;\n                for (var xx = xxMin; xx <= xxMax; xx++) {\n                    var isUsed = this.used[xx + step];\n                    if (isUsed != funcs.USED && this.isAligned(xx, yy, regAngle, prec)) {\n                        var angle = this.angles[xx + step];\n                        isUsed = funcs.USED;\n                        this.used[xx + step] = funcs.USED;\n                        var regionPoint = new types_1.RegionPoint(xx, yy, angle, this.modgrad[xx + step], isUsed);\n                        reg.push(regionPoint);\n                        sumdx += Math.cos(angle);\n                        sumdy += Math.sin(angle);\n                        regAngle = Math.atan2(sumdy, sumdx);\n                    }\n                }\n            }\n        }\n        return regAngle;\n    };\n    LSD.prototype.isAligned = function (x, y, theta, prec) {\n        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {\n            return false;\n        }\n        var a = this.angles[x + y * this.width];\n        if (a === funcs.NOT_DEF) {\n            return false;\n        }\n        var nTheta = theta - a;\n        if (nTheta < 0) {\n            nTheta = -nTheta;\n        }\n        if (nTheta > funcs.M_3_2_PI) {\n            nTheta -= funcs.M_2__PI;\n            if (nTheta < 0) {\n                nTheta = -nTheta;\n            }\n        }\n        return nTheta <= prec;\n    };\n    LSD.prototype.region2Rect = function (reg, regAngle, prec, p, rect) {\n        var x = 0, y = 0, sum = 0;\n        for (var i = 0; i < reg.length; i++) {\n            var pnt = reg[i];\n            var weight = pnt.modgrad;\n            x += pnt.x * weight;\n            y += pnt.y * weight;\n            sum += weight;\n        }\n        if (sum <= 0) {\n            throw new Error('weighted sum must differ from 0');\n        }\n        x /= sum;\n        y /= sum;\n        var theta = this.getTheta(reg, x, y, regAngle, prec);\n        var dx = Math.cos(theta);\n        var dy = Math.sin(theta);\n        var lMin = 0, lMax = 0, wMin = 0, wMax = 0;\n        for (var i = 0; i < reg.length; i++) {\n            var regdx = reg[i].x - x;\n            var regdy = reg[i].y - y;\n            var l = regdx * dx + regdy * dy;\n            var w = -regdx * dy + regdy * dx;\n            if (l > lMax) {\n                lMax = l;\n            }\n            else if (l < lMin) {\n                lMin = l;\n            }\n            if (w > wMax) {\n                wMax = w;\n            }\n            else if (w < wMin) {\n                wMin = w;\n            }\n        }\n        rect.x1 = x + lMin * dx;\n        rect.y1 = y + lMin * dy;\n        rect.x2 = x + lMax * dx;\n        rect.y2 = y + lMax * dy;\n        rect.width = wMax - wMin;\n        rect.x = x;\n        rect.y = y;\n        rect.theta = theta;\n        rect.dx = dx;\n        rect.dy = dy;\n        rect.prec = prec;\n        rect.p = p;\n        if (rect.width < 1.0) {\n            rect.width = 1.0;\n        }\n    };\n    LSD.prototype.getTheta = function (reg, x, y, regAngle, prec) {\n        var ixx = 0.0, iyy = 0.0, ixy = 0.0;\n        for (var i = 0; i < reg.length; i++) {\n            var regx = reg[i].x;\n            var regy = reg[i].y;\n            var weight = reg[i].modgrad;\n            var dx = regx - x;\n            var dy = regy - y;\n            ixx += dy * dy * weight;\n            iyy += dx * dx * weight;\n            ixy -= dx * dy * weight;\n        }\n        var check = (funcs.doubleEqual(ixx, 0) && funcs.doubleEqual(iyy, 0) && funcs.doubleEqual(ixy, 0));\n        if (check) {\n            throw new Error('check if inertia matrix is null');\n        }\n        var lambda = 0.5 * (ixx + iyy - Math.sqrt((ixx - iyy) * (ixx - iyy) + 4.0 * ixy * ixy));\n        var theta = (Math.abs(ixx) > Math.abs(iyy)) ? Math.atan2(lambda - ixx, ixy) :\n            Math.atan2(ixy, lambda - iyy);\n        if (funcs.angleDiff(theta, regAngle) > prec) {\n            theta += Math.PI;\n        }\n        return theta;\n    };\n    LSD.prototype.refine = function (reg, regAngle, prec, p, rect, densityTh) {\n        var density = reg.length / (funcs.dist(rect.x1, rect.y1, rect.x2, rect.y2) * rect.width);\n        if (density >= densityTh) {\n            return true;\n        }\n        var xc = reg[0].x;\n        var yc = reg[0].y;\n        var angC = reg[0].angle;\n        var sum = 0, sSum = 0, n = 0;\n        for (var i = 0; i < reg.length; i++) {\n            reg[i].used = funcs.NOT_USED;\n            if (funcs.dist(xc, yc, reg[i].x, reg[i].y) < rect.width) {\n                var angle = reg[i].angle;\n                var angD = funcs.angleDiff(angle, angC);\n                sum += angD;\n                sSum += angD * angD;\n                n++;\n            }\n            var meanAngle = sum / n;\n            var tau = 2.0 * Math.sqrt((sSum - 2.0 * meanAngle * sum) / n + meanAngle * meanAngle);\n            this.regionGrow(new types_1.Point(reg[0].x, reg[0].y), reg, regAngle, tau);\n            if (reg.length < 2) {\n                return false;\n            }\n            this.region2Rect(reg, regAngle, prec, p, rect);\n            density = reg.length / (funcs.dist(rect.x1, rect.y1, rect.x2, rect.y2) * rect.width);\n            if (density < densityTh) {\n                return this.reduceRegionRadius(reg, regAngle, prec, p, rect, density, densityTh);\n            }\n            else {\n                return true;\n            }\n        }\n        return false; // type guard (unreachable)\n    };\n    LSD.prototype.reduceRegionRadius = function (reg, regAngle, prec, p, rect, density, densityTh) {\n        var xc = reg[0].x;\n        var yc = reg[0].y;\n        var radSq1 = funcs.distSq(xc, yc, rect.x1, rect.y1);\n        var radSq2 = funcs.distSq(xc, yc, rect.x2, rect.y2);\n        var radSq = radSq1 > radSq2 ? radSq1 : radSq2;\n        while (density < densityTh) {\n            radSq *= 0.75 * 0.75; // reduce region's radius to 75%\n            for (var i = 0; i < reg.length; i++) {\n                if (funcs.distSq(xc, yc, reg[i].x, reg[i].y) > radSq) {\n                    // remove point from the region\n                    reg[i].used = funcs.NOT_USED;\n                    var tmp = reg[i];\n                    reg[i] = reg[reg.length - 1];\n                    reg[reg.length - 1] = tmp;\n                    reg.pop();\n                    --i;\n                }\n            }\n            if (reg.length < 2) {\n                return false;\n            }\n            this.region2Rect(reg, regAngle, prec, p, rect);\n            density = reg.length / (funcs.dist(rect.x1, rect.y1, rect.x2, rect.y2) * rect.width);\n        }\n        return true;\n    };\n    LSD.prototype.improveRect = function (rect) {\n        var delta = 0.5;\n        var delta2 = delta / 2.0;\n        var logNfa = this.rectNfa(rect);\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        var r = new types_1.Rect();\n        r.copy(rect);\n        for (var n = 0; n < 5; n++) {\n            r.p /= 2;\n            r.prec = r.p * Math.PI;\n            var logNfaNew = this.rectNfa(rect);\n            if (logNfaNew > logNfa) {\n                logNfa = logNfaNew;\n                rect.copy(r);\n            }\n        }\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        r.copy(rect);\n        for (var n = 0; n < 5; n++) {\n            if ((r.width - delta) >= 0.5) {\n                r.width -= delta;\n                var logNfaNew = this.rectNfa(r);\n                if (logNfaNew > logNfa) {\n                    rect.copy(r);\n                    logNfa = logNfaNew;\n                }\n            }\n        }\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        r.copy(rect);\n        for (var n = 0; n < 5; n++) {\n            if ((r.width - delta) >= 0.5) {\n                r.x1 -= -r.dy * delta2;\n                r.y1 -= r.dx * delta2;\n                r.x2 -= -r.dy * delta2;\n                r.y2 -= r.dx * delta2;\n                r.width -= delta;\n                var logNfaNew = this.rectNfa(r);\n                if (logNfaNew > logNfa) {\n                    rect.copy(r);\n                    logNfa = logNfaNew;\n                }\n            }\n        }\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        r.copy(rect);\n        for (var n = 0; n < 5; n++) {\n            if ((r.width - delta) >= 0.5) {\n                r.p /= 2;\n                r.prec = r.p * Math.PI;\n                var logNfaNew = this.rectNfa(r);\n                if (logNfaNew > logNfa) {\n                    rect.copy(r);\n                    logNfa = logNfaNew;\n                }\n            }\n        }\n        return logNfa;\n    };\n    LSD.prototype.rectNfa = function (rect) {\n        var totalPts = 0, algPts = 0, halfWidth = rect.width / 2.0, dyhw = rect.dy * halfWidth, dxhw = rect.dx * halfWidth, orderedX = [\n            new types_1.Edge(),\n            new types_1.Edge(),\n            new types_1.Edge(),\n            new types_1.Edge()\n        ], minY = orderedX[0], maxY = orderedX[0];\n        orderedX[0].p.x = rect.x1 - dyhw;\n        orderedX[0].p.y = rect.y1 + dxhw;\n        orderedX[1].p.x = rect.x2 - dyhw;\n        orderedX[1].p.y = rect.y2 + dxhw;\n        orderedX[2].p.x = rect.x2 + dyhw;\n        orderedX[2].p.y = rect.y2 - dxhw;\n        orderedX[3].p.x = rect.x1 + dyhw;\n        orderedX[3].p.y = rect.y1 - dxhw;\n        orderedX.sort(funcs.AsmallerB_XoverY);\n        for (var i = 1; i < 4; i++) {\n            if (minY.p.y > orderedX[i].p.y) {\n                minY = orderedX[i];\n            }\n            if (maxY.p.y < orderedX[i].p.y) {\n                maxY = orderedX[i];\n            }\n        }\n        minY.taken = true;\n        var leftmost = null;\n        for (var i = 0; i < 4; i++) {\n            if (!orderedX[i].taken) {\n                if (!leftmost) {\n                    leftmost = orderedX[i];\n                }\n                else if (leftmost.p.x > orderedX[i].p.x) {\n                    leftmost = orderedX[i];\n                }\n            }\n        }\n        if (!leftmost)\n            throw new Error('leftmost error'); // type guard\n        leftmost.taken = true;\n        var rightmost = null;\n        for (var i = 0; i < 4; i++) {\n            if (!orderedX[i].taken) {\n                if (!rightmost) {\n                    rightmost = orderedX[i];\n                }\n                else if (rightmost.p.x < orderedX[i].p.x) {\n                    rightmost = orderedX[i];\n                }\n            }\n        }\n        if (!rightmost)\n            throw new Error('rightmost error'); // type guard\n        rightmost.taken = true;\n        var tailp = null;\n        for (var i = 0; i < 4; i++) {\n            if (!orderedX[i].taken) {\n                if (!tailp) {\n                    tailp = orderedX[i];\n                }\n                else if (tailp.p.x > orderedX[i].p.x) {\n                    tailp = orderedX[i];\n                }\n            }\n        }\n        if (!tailp)\n            throw new Error('tailp error'); // type guard\n        tailp.taken = true;\n        var flstep = (minY.p.y != leftmost.p.y) ?\n            (minY.p.x + leftmost.p.x) / (minY.p.y - leftmost.p.y) : 0;\n        var slstep = (leftmost.p.y != tailp.p.x) ?\n            (leftmost.p.x = tailp.p.x) / (leftmost.p.y - tailp.p.x) : 0;\n        var frstep = (minY.p.y != rightmost.p.y) ?\n            (minY.p.x - rightmost.p.x) / (minY.p.y - rightmost.p.y) : 0;\n        var srstep = (rightmost.p.y != tailp.p.x) ?\n            (rightmost.p.x - tailp.p.x) / (rightmost.p.y - tailp.p.x) : 0;\n        var lstep = flstep, rstep = frstep;\n        var leftX = minY.p.x, rightX = minY.p.x;\n        var minIter = minY.p.y;\n        var maxIter = maxY.p.y;\n        for (var y = minIter; y <= maxIter; y++) {\n            if (y < 0 || y >= this.height) {\n                continue;\n            }\n            for (var x = leftX; x <= rightX; x++) {\n                if (x < 0 || x >= this.width) {\n                    continue;\n                }\n                totalPts++;\n                if (this.isAligned(x, y, rect.theta, rect.prec)) {\n                    algPts++;\n                }\n            }\n            if (y >= leftmost.p.y) {\n                lstep = slstep;\n            }\n            if (y >= rightmost.p.y) {\n                rstep = srstep;\n            }\n            leftX += lstep;\n            rightX += rstep;\n        }\n        return this.nfa(totalPts, algPts, rect.p);\n    };\n    LSD.prototype.nfa = function (n, k, p) {\n        var LOG_NT = 5 * (Math.log10(this.width) + Math.log10(this.height)) / 2 + Math.log10(11.0);\n        if (n == 0 || k == 0) {\n            return -LOG_NT;\n        }\n        if (n == k) {\n            return -LOG_NT - n * Math.log10(p);\n        }\n        var pTerm = p / (1 - p);\n        var log1Term = (n + 1) - funcs.logGamma(k + 1)\n            - funcs.logGamma(n - k + 1)\n            + k * Math.log(p) + (n - k) * Math.log(1.0 - p);\n        var term = Math.exp(log1Term);\n        if (funcs.doubleEqual(term, 0)) {\n            if (k > n * p) {\n                return -log1Term / funcs.M_LN10 - LOG_NT;\n            }\n            else {\n                return -LOG_NT;\n            }\n        }\n        var binTail = term;\n        var tolerance = 0.1;\n        for (var i = k + 1; i <= n; i++) {\n            var binTerm = (n - i + 1) / i;\n            var multTerm = binTerm * pTerm;\n            term *= multTerm;\n            binTail += term;\n            if (binTerm < 1) {\n                var err = term * ((1 - Math.pow(multTerm, (n - i + 1))) / (1 - multTerm) - 1);\n                if (err < tolerance * Math.abs(-Math.log10(binTail) - LOG_NT) * binTail) {\n                    break;\n                }\n            }\n        }\n        return -Math.log10(binTail) - LOG_NT;\n    };\n    LSD.prototype.gaussianBlur = function (imageData, kSize, sigma) {\n        var width = this.width, height = this.height, src = imageData, tmp = new ImageData(width, height), dst = null, kernel = this.getGaussianKernel(kSize, sigma), r = (kSize - 1) / 2;\n        var tmp2 = this.reshape(tmp);\n        dst = new Uint8ClampedArray(tmp2.length);\n        // separate 2d-filter\n        for (var y = 0; y < height; y++) {\n            var step = y * width;\n            for (var x = 0; x < width; x++) {\n                var buff = 0;\n                var i = x + step;\n                var k = 0;\n                for (var kx = -r; kx <= r; kx++) {\n                    var px = x + kx;\n                    if (px <= 0 || width <= px) {\n                        px = x;\n                    }\n                    var j = px + step;\n                    buff += src[j] * kernel[k];\n                    k++;\n                }\n                tmp2[i] = buff;\n            }\n        }\n        for (var x = 0; x < width; x++) {\n            for (var y = 0; y < height; y++) {\n                var step = y * width;\n                var buff = 0;\n                var i = x + step;\n                var k = 0;\n                for (var ky = -r; ky <= r; ky++) {\n                    var py = y + ky;\n                    var kStep = ky * width;\n                    if (py <= 0 || height <= py) {\n                        py = y;\n                        kStep = 0;\n                    }\n                    var j = i + kStep;\n                    buff += tmp2[j] * kernel[k];\n                    k++;\n                }\n                dst[i] = buff;\n            }\n        }\n        return dst;\n    };\n    LSD.prototype.getGaussianKernel = function (kSize, sigma) {\n        // 1d-kernel\n        var kernel = [];\n        var sigmaX = sigma > 0 ? sigma : ((kSize - 1) * 0.5 - 1) * 0.3 + 0.8;\n        var scale2X = -0.5 / (sigmaX * sigmaX);\n        var sum = 0.0;\n        for (var i = 0; i < kSize; i++) {\n            var x = i - (kSize - 1) * 0.5;\n            kernel[i] = Math.exp(scale2X * x * x);\n            sum += kernel[i];\n        }\n        sum = 1. / sum;\n        for (var i = 0; i < kSize; i++) {\n            kernel[i] *= sum;\n        }\n        return kernel;\n    };\n    LSD.prototype.reshape = function (image) {\n        var src = image.data;\n        var reshaped = new Uint8ClampedArray(src.length / 4);\n        var len = reshaped.length;\n        for (var i = 0; i < len; i++) {\n            reshaped[i] = src[i * 4];\n        }\n        return reshaped;\n    };\n    LSD.prototype.at = function (data, p) {\n        return data[p.x + (p.y * this.width)];\n    };\n    LSD.prototype.row = function (data, rowIndex) {\n        var i = rowIndex * this.width;\n        return data.subarray(i, i + this.width);\n    };\n    LSD.prototype.setRow = function (data, index, value) {\n        var from = index * this.width;\n        var to = from + this.width;\n        for (var i = from; i < to; i++) {\n            data[i] = value;\n        }\n        return data;\n    };\n    LSD.prototype.setCol = function (data, index, value) {\n        var to = this.height * this.width;\n        var step = this.width;\n        for (var i = index; i < to; i += step) {\n            data[i] = value;\n        }\n        return data;\n    };\n    return LSD;\n}());\nexports.default = LSD;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * constants and utility math functions\n */\nvar M_3_2_PI = (3 * Math.PI) / 2;\nexports.M_3_2_PI = M_3_2_PI;\nvar M_2__PI = (2 * Math.PI);\nexports.M_2__PI = M_2__PI;\nvar M_LN10 = 2.30258509299404568402;\nexports.M_LN10 = M_LN10;\nvar NOT_DEF = -1024.0;\nexports.NOT_DEF = NOT_DEF;\nvar USED = 1;\nexports.USED = USED;\nvar NOT_USED = 0;\nexports.NOT_USED = NOT_USED;\nvar RELATIVE_ERROR_FACTOR = 100.0;\nexports.RELATIVE_ERROR_FACTOR = RELATIVE_ERROR_FACTOR;\nvar DEG_TO_RADS = Math.PI / 180;\nexports.DEG_TO_RADS = DEG_TO_RADS;\nvar REFINE_NONE = 0;\nexports.REFINE_NONE = REFINE_NONE;\nvar REFINE_STD = 1;\nexports.REFINE_STD = REFINE_STD;\nvar REFINE_ADV = 2;\nexports.REFINE_ADV = REFINE_ADV;\nvar logGamma = function (x) { return x > 15.0 ? logGammaWindschitl(x) : logGammaLanczos(x); };\nexports.logGamma = logGamma;\nvar logGammaWindschitl = function (x) {\n    return 0.918938533204673 + (x - 0.5) * Math.log(x) - x\n        + 0.5 * x * Math.log(x * Math.sinh(1 / x) + 1 / (810.0 * Math.pow(x, 6.0)));\n};\nfunction logGammaLanczos(x) {\n    var q = [\n        75122.6331530, 80916.6278952, 36308.2951477,\n        8687.24529705, 1168.92649479, 83.8676043424,\n        2.50662827511\n    ];\n    var a = (x + 0.5) * Math.log(x + 5.5) - (x + 5.5);\n    var b = 0;\n    for (var n = 0; n < 7; ++n) {\n        a -= Math.log(x + n);\n        b += q[n] * Math.pow(x, n);\n    }\n    return a + Math.log(b);\n}\nvar distSq = function (x1, x2, y1, y2) {\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n};\nexports.distSq = distSq;\nvar dist = function (x1, x2, y1, y2) { return Math.sqrt(distSq(x1, y1, x2, y2)); };\nexports.dist = dist;\nfunction angleDiffSigned(a, b) {\n    var diff = a - b;\n    var PI = Math.PI;\n    while (diff <= -PI) {\n        diff += M_2__PI;\n    }\n    while (diff > PI) {\n        diff -= M_2__PI;\n    }\n    return diff;\n}\nfunction angleDiff(a, b) {\n    var value = angleDiffSigned(a, b);\n    return value >= 0 ? value : -value;\n}\nexports.angleDiff = angleDiff;\nfunction doubleEqual(a, b) {\n    if (a == b) {\n        return true;\n    }\n    var diff = a - b;\n    var absDiff = diff >= 0 ? diff : -diff;\n    var aa = a >= 0 ? a : -a;\n    var bb = b >= 0 ? b : -b;\n    var absMax = (aa > bb) ? aa : bb;\n    var MIN_VALUE = Number.MIN_VALUE;\n    if (absMax < MIN_VALUE) {\n        absMax = MIN_VALUE;\n    }\n    return (absDiff / absMax) <= (RELATIVE_ERROR_FACTOR * Number.EPSILON);\n}\nexports.doubleEqual = doubleEqual;\nfunction AsmallerB_XoverY(a, b) {\n    if (a.p.x == b.p.x) {\n        return Number(a.p.y < b.p.y);\n    }\n    else {\n        return Number(a.p.x < b.p.x);\n    }\n}\nexports.AsmallerB_XoverY = AsmallerB_XoverY;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Vec4 = /** @class */ (function () {\n    function Vec4(x1, y1, x2, y2) {\n        if (x1 === void 0) { x1 = 0; }\n        if (y1 === void 0) { y1 = 0; }\n        if (x2 === void 0) { x2 = 0; }\n        if (y2 === void 0) { y2 = 0; }\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n    return Vec4;\n}());\nexports.Vec4 = Vec4;\nvar Point = /** @class */ (function () {\n    function Point(x, y) {\n        if (x === void 0) { x = 0.0; }\n        if (y === void 0) { y = 0.0; }\n        this.x = x;\n        this.y = y;\n    }\n    return Point;\n}());\nexports.Point = Point;\nvar CoorList = /** @class */ (function () {\n    function CoorList() {\n        this.p = new Point();\n    }\n    return CoorList;\n}());\nexports.CoorList = CoorList;\nvar RegionPoint = /** @class */ (function () {\n    function RegionPoint(x, y, angle, modgrad, used) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (angle === void 0) { angle = 0.0; }\n        if (modgrad === void 0) { modgrad = 0.0; }\n        this.x = x;\n        this.y = y;\n        this.angle = angle;\n        this.modgrad = modgrad;\n        this.used = used;\n    }\n    return RegionPoint;\n}());\nexports.RegionPoint = RegionPoint;\nvar Rect = /** @class */ (function () {\n    function Rect(x1, y1, x2, y2, width, height, x, y, theta, dx, dy, prec, p) {\n        if (x1 === void 0) { x1 = 0; }\n        if (y1 === void 0) { y1 = 0; }\n        if (x2 === void 0) { x2 = 0; }\n        if (y2 === void 0) { y2 = 0; }\n        if (width === void 0) { width = 0; }\n        if (height === void 0) { height = 0; }\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (theta === void 0) { theta = 0; }\n        if (dx === void 0) { dx = 0; }\n        if (dy === void 0) { dy = 0; }\n        if (prec === void 0) { prec = 0; }\n        if (p === void 0) { p = 0; }\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        this.theta = theta;\n        this.dx = dx;\n        this.dy = dy;\n        this.prec = prec;\n        this.p = p;\n    }\n    Rect.prototype.copy = function (rect) {\n        this.x1 = rect.x1;\n        this.y1 = rect.y1;\n        this.x2 = rect.x2;\n        this.y2 = rect.y2;\n        this.width = rect.width;\n        this.height = rect.height;\n        this.x = rect.x;\n        this.y = rect.y;\n        this.theta = rect.theta;\n        this.dx = rect.dx;\n        this.dy = rect.dy;\n        this.prec = rect.prec;\n        this.p = rect.p;\n    };\n    return Rect;\n}());\nexports.Rect = Rect;\nvar Edge = /** @class */ (function () {\n    function Edge() {\n        this.p = new Point();\n    }\n    return Edge;\n}());\nexports.Edge = Edge;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// lsd.js","/**\n * Line Segment Detector (LSD) module\n * @author https://github.com/wellflat\n */\n\nimport * as funcs from './funcs';\nimport { Vec4, Point, CoorList, RegionPoint, Rect, Edge } from './types';\n\n/**\n * Create a LineSegmentDetector object.\n * Specifying scale, number of subdivisions for the image,\n * should the lines be refined and other constants as follows:\n *\n * @param refine       How should the lines found be refined?\n *                      REFINE_NONE - No refinement applied.\n *                      REFINE_STD  - Standard refinement is applied. E.g. breaking arches into smaller line approximations.\n *                      REFINE_ADV  - Advanced refinement. Number of false alarms is calculated,\n *                                    lines are refined through increase of precision, decrement in size, etc.\n * @param scale        The scale of the image that will be used to find the lines. Range (0..1].\n * @param sigmaScale   Sigma for Gaussian filter is computed as sigma = _sigma_scale/_scale.\n * @param quant        Bound to the quantization error on the gradient norm.\n * @param angTh        Gradient angle tolerance in degrees.\n * @param logEps       Detection threshold: -log10(NFA) > _log_eps\n * @param densityTh    Minimal density of aligned region points in rectangle.\n * @param nBins        Number of bins in pseudo-ordering of gradient modulus.\n */\nexport default class LSD {\n    image?: ImageData;\n    private imageData?: Uint8ClampedArray;\n    width = 0;\n    height = 0;\n    list: CoorList[] = [];\n    angles?: Float64Array;\n    modgrad?: Float64Array;\n    used?: Uint8Array;\n\n    constructor(\n        public refineType = funcs.REFINE_NONE, public scale = 0.8, public sigmaScale = 0.6, public quant = 2.0,\n        public angTh = 22.5, public logEps = 0.0, public densityTh = 0.7, public nBins = 1024\n    ) { }\n    /**\n     * Detect lines in the input image.\n     * @param {ImageData} image\n     * @return {Vec4[]}\n     */\n    detect(image: ImageData) {\n        this.image = image;\n        this.width = image.width;\n        this.height = image.height;\n        const lines = this.lsd();\n        return lines;\n    }\n    /**\n     * Draws the line segments on a given image.\n     * @param {CanvasRenderingContext2D} context\n     * @param {Vec4[]} lines\n     * @param {string} color\n     */\n    drawSegments(context: CanvasRenderingContext2D, lines: Vec4[], color = '#ff0000') {\n        context.strokeStyle = color;\n        context.lineWidth = 1;\n        lines.forEach(v => {\n            context.beginPath();\n            context.moveTo(v.x1, v.y1);\n            context.lineTo(v.x2, v.y2);\n            context.stroke();\n            context.closePath();\n        });\n    }\n\n    /**\n     * for debug\n     * @param {CanvasRenderingContext2D} context\n     */\n    putImageData(context: CanvasRenderingContext2D) {\n        let src = this.imageData,\n            image = context.createImageData(this.width, this.height),\n            dst = image.data,\n            len = image.data.length;\n        if (!src) throw new Error('imageData required'); // type guard\n        for (let i = 0; i < len; i += 4) {\n            dst[i] = dst[i + 1] = dst[i + 2] = src[i/4];\n            dst[i + 3] = 255;\n        }\n        context.putImageData(image, 0, 0);\n    }\n    /**\n     * @return {Vec4[]}  Return: A vector of Vec4f elements specifying the beginning and ending point of a line.\n     *                   Where Vec4f is (x1, y1, x2, y2), point 1 is the start, point 2 - end.\n     *                   Returned lines are strictly oriented depending on the gradient.\n     */\n    lsd() {\n        if (!this.image || !this.angles) throw new Error('image and angles required'); // type guard\n        /** @type {Vec4[]} */\n        let lines = [];\n        const prec = Math.PI * this.angTh / 180;\n        const p = this.angTh / 180;\n        const rho = this.quant / Math.sin(prec);\n        if (this.scale != 1) {\n            const sigma = this.scale < 1 ? this.sigmaScale / this.scale : this.sigmaScale;\n            const sprec = 3;\n            const h = Math.ceil(sigma * Math.sqrt(2 * sprec * Math.log(10.0)));\n            const kSize = 1 + 2 * h;\n            const reshaped = this.reshape(this.image);\n            this.imageData = this.gaussianBlur(reshaped, kSize, sigma);\n            this.computeLevelLineAngles(rho, this.nBins);\n        } else {\n            this.imageData = this.reshape(this.image);\n            this.computeLevelLineAngles(rho, this.nBins);\n        }\n\n        const LOG_NT = 5 * (Math.log10(this.width) + Math.log10(this.height)) / 2 + Math.log10(11.0);\n        const minRegSize = -LOG_NT / Math.log10(p);\n        this.used = new Uint8Array(this.imageData.length);\n        for (let i = 0, listSize = this.list.length; i < listSize; i++) {\n            const point = this.list[i].p;\n            if ((this.at(this.used, point) === funcs.NOT_USED) &&\n                (this.at(this.angles, point) !== funcs.NOT_DEF)) {\n                let regAngle = 0.0;\n                let reg: RegionPoint[] = [];\n                regAngle = this.regionGrow(this.list[i].p, reg, regAngle, prec);\n                if (reg.length < minRegSize) {\n                    continue;\n                }\n                let rect = new Rect();\n                this.region2Rect(reg, regAngle, prec, p, rect);\n                let logNfa = -1;\n                if (this.refineType > funcs.REFINE_NONE) {\n                    if (!this.refine(reg, regAngle, prec, p, rect, this.densityTh)) {\n                        continue;\n                    }\n                    if (this.refineType >= funcs.REFINE_ADV) {\n                        logNfa = this.improveRect(rect);\n                        if (logNfa <= this.logEps) {\n                            continue;\n                        }\n                    }\n                }\n                rect.x1 += 0.5;\n                rect.y1 += 0.5;\n                rect.x2 += 0.5;\n                rect.y2 += 0.5;\n                /*\n                if (this.scale != 1) {\n                    rect.x1 /= this.scale;\n                    rect.y1 /= this.scale;\n                    rect.x2 /= this.scale;\n                    rect.y2 /= this.scale;\n                    rect.width /= this.scale;\n                }\n                */\n                lines.push(new Vec4(rect.x1, rect.y1, rect.x2, rect.y2));\n            }\n        }\n        return lines;\n    }\n\n    /**\n     * @param {number} threshold The minimum value of the angle that is considered defined, otherwise NOTDEF\n     * @param {number} nBins     The number of bins with which gradients are ordered by, using bucket sort.\n     */\n    computeLevelLineAngles(threshold: number, nBins: number) {\n        const imageData = this.imageData;\n        if (!imageData) throw new Error('imageData required'); // type guard\n        const width = this.width;\n        const height = this.height;\n        this.angles = new Float64Array(imageData.length);\n        this.modgrad = new Float64Array(imageData.length);\n        this.angles = this.setRow(this.angles, height - 1, funcs.NOT_DEF);\n        this.angles = this.setCol(this.angles, width - 1, funcs.NOT_DEF);\n        let maxGrad = -1.0;\n        for (let y = 0; y < height - 1; y++) {\n            const step = y * width;\n            const nextStep = (y + 1) * width;\n            for (let x = 0; x < width - 1; x++) {\n                const DA = imageData[x + 1 + nextStep] - imageData[x + step];\n                const BC = imageData[x + 1 + step] - imageData[x + nextStep];\n                const gx = DA + BC;\n                const gy = DA - BC;\n                const norm = Math.sqrt((gx * gx + gy * gy) / 4.0);\n                this.modgrad[x + step] = norm;\n                if (norm <= threshold) {\n                    this.angles[x + step] = funcs.NOT_DEF;\n                } else {\n                    this.angles[x + step] = Math.atan2(gx, -gy);\n                    if (norm > maxGrad) {\n                        maxGrad = norm;\n                    }\n                }\n            }\n        }\n        /** @type {CoorList[]} */\n        let rangeS = [];\n        rangeS.length = nBins;\n        /** @type {CoorList[]} */\n        let rangeE = [];\n        rangeE.length = nBins;\n        let count = 0;\n        const binCoef = (maxGrad > 0) ? (nBins - 1) / maxGrad : 0;\n        for (let y = 0; y < height - 1; y++) {\n            let step = y * width;\n            for (let x = 0; x < width - 1; x++) {\n                let i = Math.floor(this.modgrad[x + step] * binCoef);\n                if (!rangeE[i]) {\n                    this.list[count] = new CoorList();\n                    rangeE[i] = rangeS[i] = this.list[count];\n                    count++;\n                } else {\n                    this.list[count] = new CoorList();\n                    rangeE[i] = this.list[count];\n                    rangeE[i].next = this.list[count];\n                    count++;\n                }\n                rangeE[i].p = new Point(x, y);\n                rangeE[i].next = null;\n            }\n        }\n        let idx = nBins - 1;\n        for (; idx > 0 && !rangeS[idx]; idx--) {\n            // do nothing.\n        }\n        let start = rangeS[idx];\n        let endIdx = idx;\n        if (start) {\n            while (idx > 0) {\n                idx--;\n                if (rangeS[idx]) {\n                    rangeE[endIdx].next = rangeS[idx];\n                    rangeE[endIdx] = rangeE[idx];\n                    endIdx = idx;\n                }\n            }\n        }\n    }\n\n    regionGrow(s: Point, reg: RegionPoint[], regAngle: number, prec: number) {\n        if (!this.used || !this.angles || !this.modgrad) throw new Error('used, angles and modgrad required'); // type guard\n        let seed = new RegionPoint();\n        seed.x = s.x;\n        seed.y = s.y;\n        seed.used = this.at(this.used, s);\n        regAngle = this.at(this.angles, s);\n        seed.angle = regAngle;\n        seed.modgrad = this.at(this.modgrad, s);\n        seed.used = funcs.USED;\n        reg.push(seed);\n        let sumdx = Math.cos(regAngle);\n        let sumdy = Math.sin(regAngle);\n\n        for (let i = 0; i < reg.length; i++) {\n            const rpoint = reg[i],\n                xxMin = Math.max(rpoint.x - 1, 0),\n                xxMax = Math.min(rpoint.x + 1, this.width - 1),\n                yyMin = Math.max(rpoint.y - 1, 0),\n                yyMax = Math.min(rpoint.y + 1, this.height - 1);\n            for (let yy = yyMin; yy <= yyMax; yy++) {\n                const step = yy * this.width;\n                for (let xx = xxMin; xx <= xxMax; xx++) {\n                    let isUsed = this.used[xx + step];\n                    if (isUsed != funcs.USED && this.isAligned(xx, yy, regAngle, prec)) {\n                        const angle = this.angles[xx + step];\n                        isUsed = funcs.USED;\n                        this.used[xx + step] = funcs.USED;\n                        let regionPoint = new RegionPoint(\n                            xx, yy, angle, this.modgrad[xx + step], isUsed\n                        );\n                        reg.push(regionPoint);\n                        sumdx += Math.cos(angle);\n                        sumdy += Math.sin(angle);\n                        regAngle = Math.atan2(sumdy, sumdx);\n                    }\n                }\n            }\n        }\n        return regAngle;\n    }\n\n    isAligned(x: number, y: number, theta: number, prec: number) {\n        if (x < 0 || y < 0 || x >= this.width || y >= this.height) {\n            return false;\n        }\n        const a = this.angles![x + y * this.width];\n        if (a === funcs.NOT_DEF) {\n            return false;\n        }\n        let nTheta = theta - a;\n        if (nTheta < 0) {\n            nTheta = -nTheta;\n        }\n        if (nTheta > funcs.M_3_2_PI) {\n            nTheta -= funcs.M_2__PI;\n            if (nTheta < 0) {\n                nTheta = -nTheta;\n            }\n        }\n        return nTheta <= prec;\n    }\n\n    region2Rect(reg: RegionPoint[], regAngle: number, prec: number, p: number, rect: Rect) {\n        let x = 0, y = 0, sum = 0;\n        for (let i = 0; i < reg.length; i++) {\n            const pnt = reg[i];\n            const weight = pnt.modgrad;\n            x += pnt.x * weight;\n            y += pnt.y * weight;\n            sum += weight;\n        }\n        if (sum <= 0) {\n            throw new Error('weighted sum must differ from 0');\n        }\n        x /= sum;\n        y /= sum;\n        const theta = this.getTheta(reg, x, y, regAngle, prec);\n        const dx = Math.cos(theta);\n        const dy = Math.sin(theta);\n        let lMin = 0, lMax = 0, wMin = 0, wMax = 0;\n        for (let i = 0; i < reg.length; i++) {\n            let regdx = reg[i].x - x;\n            let regdy = reg[i].y - y;\n            let l = regdx * dx + regdy * dy;\n            let w = -regdx * dy + regdy * dx;\n            if (l > lMax) {\n                lMax = l;\n            } else if (l < lMin) {\n                lMin = l;\n            }\n            if (w > wMax) {\n                wMax = w;\n            } else if (w < wMin) {\n                wMin = w;\n            }\n        }\n        rect.x1 = x + lMin * dx;\n        rect.y1 = y + lMin * dy;\n        rect.x2 = x + lMax * dx;\n        rect.y2 = y + lMax * dy;\n        rect.width = wMax - wMin;\n        rect.x = x;\n        rect.y = y;\n        rect.theta = theta;\n        rect.dx = dx;\n        rect.dy = dy;\n        rect.prec = prec;\n        rect.p = p;\n        if (rect.width < 1.0) {\n            rect.width = 1.0;\n        }\n    }\n\n    getTheta(reg: RegionPoint[], x: number, y: number, regAngle: number, prec: number) {\n        let ixx = 0.0,\n            iyy = 0.0,\n            ixy = 0.0;\n        for (let i = 0; i < reg.length; i++) {\n            const regx = reg[i].x;\n            const regy = reg[i].y;\n            const weight = reg[i].modgrad;\n            let dx = regx - x;\n            let dy = regy - y;\n            ixx += dy * dy * weight;\n            iyy += dx * dx * weight;\n            ixy -= dx * dy * weight;\n        }\n        let check = (funcs.doubleEqual(ixx, 0) && funcs.doubleEqual(iyy, 0) && funcs.doubleEqual(ixy, 0));\n        if (check) {\n            throw new Error('check if inertia matrix is null');\n        }\n        let lambda = 0.5 * (ixx + iyy - Math.sqrt((ixx - iyy) * (ixx - iyy) + 4.0 * ixy * ixy));\n        let theta = (Math.abs(ixx) > Math.abs(iyy)) ? Math.atan2(lambda - ixx, ixy) :\n            Math.atan2(ixy, lambda - iyy);\n        if (funcs.angleDiff(theta, regAngle) > prec) {\n            theta += Math.PI;\n        }\n        return theta;\n    }\n\n    refine(reg: RegionPoint[], regAngle: number, prec: number, p: number, rect: Rect, densityTh: number) {\n        let density = reg.length / (funcs.dist(rect.x1, rect.y1, rect.x2, rect.y2) * rect.width);\n        if (density >= densityTh) {\n            return true;\n        }\n        let xc = reg[0].x;\n        let yc = reg[0].y;\n        const angC = reg[0].angle;\n        let sum = 0, sSum = 0, n = 0;\n        for (let i = 0; i < reg.length; i++) {\n            reg[i].used = funcs.NOT_USED;\n            if (funcs.dist(xc, yc, reg[i].x, reg[i].y) < rect.width) {\n                const angle = reg[i].angle;\n                let angD = funcs.angleDiff(angle, angC);\n                sum += angD;\n                sSum += angD * angD;\n                n++;\n            }\n            let meanAngle = sum / n;\n            let tau = 2.0 * Math.sqrt((sSum - 2.0 * meanAngle * sum) / n + meanAngle * meanAngle);\n            this.regionGrow(new Point(reg[0].x, reg[0].y), reg, regAngle, tau);\n            if (reg.length < 2) {\n                return false;\n            }\n            this.region2Rect(reg, regAngle, prec, p, rect);\n            density = reg.length / (funcs.dist(rect.x1, rect.y1, rect.x2, rect.y2) * rect.width);\n            if (density < densityTh) {\n                return this.reduceRegionRadius(reg, regAngle, prec, p, rect, density, densityTh);\n            } else {\n                return true;\n            }\n        }\n        return false; // type guard (unreachable)\n    }\n\n    reduceRegionRadius(reg: RegionPoint[], regAngle: number, prec: number, p: number, rect: Rect, density: number, densityTh: number) {\n        let xc = reg[0].x;\n        let yc = reg[0].y;\n        let radSq1 = funcs.distSq(xc, yc, rect.x1, rect.y1);\n        let radSq2 = funcs.distSq(xc, yc, rect.x2, rect.y2);\n        let radSq = radSq1 > radSq2 ? radSq1 : radSq2;\n        while (density < densityTh) {\n            radSq *= 0.75 * 0.75; // reduce region's radius to 75%\n            for (let i = 0; i < reg.length; i++) {\n                if (funcs.distSq(xc, yc, reg[i].x, reg[i].y) > radSq) {\n                    // remove point from the region\n                    reg[i].used = funcs.NOT_USED;\n                    const tmp = reg[i];\n                    reg[i] = reg[reg.length - 1];\n                    reg[reg.length - 1] = tmp;\n                    reg.pop();\n                    --i;\n                }\n            }\n            if (reg.length < 2) {\n                return false;\n            }\n            this.region2Rect(reg, regAngle, prec, p, rect);\n            density = reg.length / (funcs.dist(rect.x1, rect.y1, rect.x2, rect.y2) * rect.width);\n        }\n        return true;\n    }\n\n    improveRect(rect: Rect) {\n        let delta = 0.5;\n        let delta2 = delta / 2.0;\n        let logNfa = this.rectNfa(rect);\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        let r = new Rect();\n        r.copy(rect);\n        for (let n = 0; n < 5; n++) {\n            r.p /= 2;\n            r.prec = r.p * Math.PI;\n            let logNfaNew = this.rectNfa(rect);\n            if (logNfaNew > logNfa) {\n                logNfa = logNfaNew;\n                rect.copy(r);\n            }\n        }\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        r.copy(rect);\n        for (let n = 0; n < 5; n++) {\n            if ((r.width - delta) >= 0.5) {\n                r.width -= delta;\n                let logNfaNew = this.rectNfa(r);\n                if (logNfaNew > logNfa) {\n                    rect.copy(r);\n                    logNfa = logNfaNew;\n                }\n            }\n        }\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        r.copy(rect);\n        for (let n = 0; n < 5; n++) {\n            if ((r.width - delta) >= 0.5) {\n                r.x1 -= -r.dy * delta2;\n                r.y1 -= r.dx * delta2;\n                r.x2 -= -r.dy * delta2;\n                r.y2 -= r.dx * delta2;\n                r.width -= delta;\n                let logNfaNew = this.rectNfa(r);\n                if (logNfaNew > logNfa) {\n                    rect.copy(r);\n                    logNfa = logNfaNew;\n                }\n            }\n        }\n        if (logNfa > this.logEps) {\n            return logNfa;\n        }\n        r.copy(rect);\n        for (let n = 0; n < 5; n++) {\n            if ((r.width - delta) >= 0.5) {\n                r.p /= 2;\n                r.prec = r.p * Math.PI;\n                let logNfaNew = this.rectNfa(r);\n                if (logNfaNew > logNfa) {\n                    rect.copy(r);\n                    logNfa = logNfaNew;\n                }\n            }\n        }\n        return logNfa;\n    }\n\n    rectNfa(rect: Rect) {\n        let totalPts = 0,\n            algPts = 0,\n            halfWidth = rect.width / 2.0,\n            dyhw = rect.dy * halfWidth,\n            dxhw = rect.dx * halfWidth,\n            orderedX = [\n                new Edge(),\n                new Edge(),\n                new Edge(),\n                new Edge()\n            ],\n            minY = orderedX[0],\n            maxY = orderedX[0];\n        orderedX[0].p.x = rect.x1 - dyhw;\n        orderedX[0].p.y = rect.y1 + dxhw;\n        orderedX[1].p.x = rect.x2 - dyhw;\n        orderedX[1].p.y = rect.y2 + dxhw;\n        orderedX[2].p.x = rect.x2 + dyhw;\n        orderedX[2].p.y = rect.y2 - dxhw;\n        orderedX[3].p.x = rect.x1 + dyhw;\n        orderedX[3].p.y = rect.y1 - dxhw;\n\n        orderedX.sort(funcs.AsmallerB_XoverY);\n\n        for (let i = 1; i < 4; i++) {\n            if (minY.p.y > orderedX[i].p.y) {\n                minY = orderedX[i];\n            }\n            if (maxY.p.y < orderedX[i].p.y) {\n                maxY = orderedX[i];\n            }\n        }\n        minY.taken = true;\n        let leftmost = null;\n        for (let i = 0; i < 4; i++) {\n            if (!orderedX[i].taken) {\n                if (!leftmost) {\n                    leftmost = orderedX[i];\n                } else if (leftmost.p.x > orderedX[i].p.x) {\n                    leftmost = orderedX[i];\n                }\n            }\n        }\n        if (!leftmost) throw new Error('leftmost error'); // type guard\n        leftmost.taken = true;\n        let rightmost = null;\n        for (let i = 0; i < 4; i++) {\n            if (!orderedX[i].taken) {\n                if (!rightmost) {\n                    rightmost = orderedX[i];\n                } else if (rightmost.p.x < orderedX[i].p.x) {\n                    rightmost = orderedX[i];\n                }\n            }\n        }\n        if (!rightmost) throw new Error('rightmost error'); // type guard\n        rightmost.taken = true;\n        let tailp = null;\n        for (let i = 0; i < 4; i++) {\n            if (!orderedX[i].taken) {\n                if (!tailp) {\n                    tailp = orderedX[i];\n                } else if (tailp.p.x > orderedX[i].p.x) {\n                    tailp = orderedX[i];\n                }\n            }\n        }\n        if (!tailp) throw new Error('tailp error'); // type guard\n        tailp.taken = true;\n        let flstep = (minY.p.y != leftmost.p.y) ?\n            (minY.p.x + leftmost.p.x) / (minY.p.y - leftmost.p.y) : 0;\n        let slstep = (leftmost.p.y != tailp.p.x) ?\n            (leftmost.p.x = tailp.p.x) / (leftmost.p.y - tailp.p.x) : 0;\n        let frstep = (minY.p.y != rightmost.p.y) ?\n            (minY.p.x - rightmost.p.x) / (minY.p.y - rightmost.p.y) : 0;\n        let srstep = (rightmost.p.y != tailp.p.x) ?\n            (rightmost.p.x - tailp.p.x) / (rightmost.p.y - tailp.p.x) : 0;\n        let lstep = flstep, rstep = frstep;\n        let leftX = minY.p.x, rightX = minY.p.x;\n        let minIter = minY.p.y;\n        let maxIter = maxY.p.y;\n        for (let y = minIter; y <= maxIter; y++) {\n            if (y < 0 || y >= this.height) {\n                continue;\n            }\n            for (let x = leftX; x <= rightX; x++) {\n                if (x < 0 || x >= this.width) {\n                    continue;\n                }\n                totalPts++;\n                if (this.isAligned(x, y, rect.theta, rect.prec)) {\n                    algPts++;\n                }\n            }\n            if (y >= leftmost.p.y) {\n                lstep = slstep;\n            }\n            if (y >= rightmost.p.y) {\n                rstep = srstep;\n            }\n            leftX += lstep;\n            rightX += rstep;\n        }\n        return this.nfa(totalPts, algPts, rect.p);\n    }\n\n    nfa(n: number, k: number, p: number) {\n        const LOG_NT =  5 * (Math.log10(this.width) + Math.log10(this.height)) / 2 + Math.log10(11.0);\n        if (n == 0 || k == 0) {\n            return -LOG_NT;\n        }\n        if (n == k) {\n            return -LOG_NT - n * Math.log10(p);\n        }\n        let pTerm = p / (1 - p);\n        let log1Term = (n + 1) - funcs.logGamma(k + 1)\n            - funcs.logGamma(n - k + 1)\n            + k * Math.log(p) + (n - k) * Math.log(1.0 - p);\n        let term = Math.exp(log1Term);\n        if (funcs.doubleEqual(term, 0)) {\n            if (k > n * p) {\n                return -log1Term / funcs.M_LN10 - LOG_NT;\n            } else {\n                return -LOG_NT;\n            }\n        }\n        let binTail = term;\n        let tolerance = 0.1;\n        for (let i = k + 1; i <= n; i++) {\n            let binTerm = (n - i + 1) / i;\n            let multTerm = binTerm * pTerm;\n            term *= multTerm;\n            binTail += term;\n            if (binTerm < 1) {\n                let err = term * ((1 - Math.pow(multTerm, (n - i + 1))) / (1 - multTerm) - 1);\n                if (err < tolerance * Math.abs(-Math.log10(binTail) - LOG_NT) * binTail) {\n                    break;\n                }\n            }\n        }\n        return -Math.log10(binTail) - LOG_NT;\n    }\n\n    gaussianBlur(imageData: Uint8ClampedArray, kSize: number, sigma: number) {\n        let width = this.width,\n            height = this.height,\n            src = imageData,\n            tmp = new ImageData(width, height),\n            dst = null,\n            kernel = this.getGaussianKernel(kSize, sigma),\n            r = (kSize - 1) / 2;\n        const tmp2 = this.reshape(tmp);\n        dst = new Uint8ClampedArray(tmp2.length);\n        // separate 2d-filter\n        for (let y = 0; y < height; y++) {\n            let step = y * width;\n            for (let x = 0; x < width; x++) {\n                let buff = 0;\n                let i = x + step;\n                let k = 0;\n                for (let kx = -r; kx <= r; kx++) {\n                    let px = x + kx;\n                    if (px <= 0 || width <= px) {\n                        px = x;\n                    }\n                    let j = px + step;\n                    buff += src[j] * kernel[k];\n                    k++;\n                }\n                tmp2[i] = buff;\n            }\n        }\n\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                let step = y * width;\n                let buff = 0;\n                let i = x + step;\n                let k = 0;\n                for (let ky = -r; ky <= r; ky++) {\n                    let py = y + ky;\n                    let kStep = ky * width;\n                    if (py <= 0 || height <= py) {\n                        py = y;\n                        kStep = 0;\n                    }\n                    let j = i + kStep;\n                    buff += tmp2[j] * kernel[k];\n                    k++;\n                }\n                dst[i] = buff;\n            }\n        }\n        return dst;\n    }\n\n    getGaussianKernel(kSize: number, sigma: number) {\n        // 1d-kernel\n        let kernel = [];\n        let sigmaX = sigma > 0 ? sigma : ((kSize - 1) * 0.5 - 1) * 0.3 + 0.8;\n        let scale2X = -0.5 / (sigmaX * sigmaX);\n        let sum = 0.0;\n        for (let i = 0; i < kSize; i++) {\n            let x = i - (kSize - 1) * 0.5;\n            kernel[i] = Math.exp(scale2X * x * x);\n            sum += kernel[i];\n        }\n        sum = 1. / sum;\n        for (let i = 0; i < kSize; i++) {\n            kernel[i] *= sum;\n        }\n        return kernel;\n    }\n\n    reshape(image: ImageData) {\n        let src = image.data;\n        let reshaped = new Uint8ClampedArray(src.length / 4);\n        let len = reshaped.length;\n        for (let i = 0; i < len; i++) {\n            reshaped[i] = src[i * 4];\n        }\n        return reshaped;\n    }\n\n    at(data: Uint8Array|Float64Array, p: Point) {\n        return data[p.x + (p.y * this.width)];\n    }\n\n    row(data: Float64Array, rowIndex: number) {\n        let i = rowIndex * this.width;\n        return data.subarray(i, i + this.width);\n    }\n\n    setRow(data: Float64Array, index: number, value: number) {\n        let from = index * this.width;\n        let to = from + this.width;\n        for (let i = from; i < to; i++) {\n            data[i] = value;\n        }\n        return data;\n    }\n\n    setCol(data: Float64Array, index: number, value: number) {\n        let to = this.height * this.width;\n        let step = this.width;\n        for (let i = index; i < to; i += step) {\n            data[i] = value;\n        }\n        return data;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lsd.ts","import { Edge } from './types';\n\n/**\n * constants and utility math functions\n */\n\nconst M_3_2_PI = (3 * Math.PI) / 2;\nconst M_2__PI = (2 * Math.PI);\nconst M_LN10 = 2.30258509299404568402;\nconst NOT_DEF = -1024.0;\nconst USED = 1;\nconst NOT_USED = 0;\nconst RELATIVE_ERROR_FACTOR = 100.0;\nconst DEG_TO_RADS = Math.PI / 180;\nconst REFINE_NONE = 0;\nconst REFINE_STD = 1;\nconst REFINE_ADV = 2;\n\n\nconst logGamma = (x: number) => x > 15.0 ? logGammaWindschitl(x) : logGammaLanczos(x);\n\nconst logGammaWindschitl = (x: number) =>\n    0.918938533204673 + (x - 0.5) * Math.log(x) - x\n    + 0.5 * x * Math.log(x * Math.sinh(1 / x) + 1 / (810.0 * Math.pow(x, 6.0)));\n\nfunction logGammaLanczos(x: number) {\n    const q = [\n        75122.6331530, 80916.6278952, 36308.2951477,\n        8687.24529705, 1168.92649479, 83.8676043424,\n        2.50662827511\n    ];\n    let a = (x + 0.5) * Math.log(x + 5.5) - (x + 5.5);\n    let b = 0;\n    for(let n = 0; n < 7; ++n) {\n        a -= Math.log(x + n);\n        b += q[n] * Math.pow(x, n);\n    }\n    return a + Math.log(b);\n}\n\nconst distSq = (x1: number, x2: number, y1: number, y2: number) =>\n    (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n\nconst dist = (x1: number, x2: number, y1: number, y2: number) => Math.sqrt(distSq(x1, y1, x2, y2));\n\nfunction angleDiffSigned(a: number, b: number) {\n    let diff = a - b;\n    const PI = Math.PI;\n    while (diff <= -PI) {\n        diff += M_2__PI;\n    }\n    while (diff > PI) {\n        diff -= M_2__PI;\n    }\n    return diff;\n}\n\nfunction angleDiff(a: number, b: number) {\n    const value = angleDiffSigned(a, b);\n    return value >= 0  ? value : -value;\n}\n\nfunction doubleEqual(a: number, b: number) {\n    if (a == b) {\n        return true;\n    }\n    const diff = a - b;\n    const absDiff = diff >= 0 ? diff : -diff;\n    const aa = a >= 0 ? a : - a;\n    const bb = b >= 0 ? b : - b;\n    let absMax = (aa > bb) ? aa : bb;\n    const MIN_VALUE = Number.MIN_VALUE;\n    if (absMax < MIN_VALUE) {\n        absMax = MIN_VALUE;\n    }\n    return (absDiff / absMax) <= (RELATIVE_ERROR_FACTOR * Number.EPSILON);\n}\n\nfunction AsmallerB_XoverY(a: Edge, b: Edge) {\n    if (a.p.x == b.p.x) {\n        return Number(a.p.y < b.p.y);\n    } else {\n        return Number(a.p.x < b.p.x);\n    }\n}\n\nexport {\n    M_3_2_PI, M_2__PI, M_LN10,\n    NOT_DEF, USED, NOT_USED, RELATIVE_ERROR_FACTOR, DEG_TO_RADS,\n    REFINE_NONE, REFINE_STD, REFINE_ADV,\n    logGamma, dist, distSq, angleDiff, doubleEqual, AsmallerB_XoverY\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/funcs.ts","class Vec4 {\n    constructor(public x1 = 0, public y1 = 0, public x2 = 0, public y2 = 0) { }\n}\n\nclass Point {\n    constructor(public x = 0.0, public y = 0.0) { }\n}\n\nclass CoorList {\n    p: Point;\n    next: CoorList | null;\n\n    constructor() {\n        this.p = new Point();\n    }\n}\n\nclass RegionPoint {\n    constructor(public x = 0, public y = 0, public angle = 0.0, public modgrad = 0.0, public used?: number) { }\n}\n\nclass Rect {\n    constructor(\n        public x1 = 0, public y1 = 0, public x2 = 0, public y2 = 0,\n        public width = 0, public height = 0, public x = 0, public y = 0, public theta = 0,\n        public dx = 0, public dy = 0, public prec = 0, public p = 0\n    ) { }\n\n    copy(rect: Rect) {\n        this.x1 = rect.x1;\n        this.y1 = rect.y1;\n        this.x2 = rect.x2;\n        this.y2 = rect.y2;\n        this.width = rect.width;\n        this.height = rect.height;\n        this.x = rect.x;\n        this.y = rect.y;\n        this.theta = rect.theta;\n        this.dx = rect.dx;\n        this.dy = rect.dy;\n        this.prec = rect.prec;\n        this.p = rect.p;\n    }\n}\n\nclass Edge {\n    p: Point;\n    taken?: boolean;\n\n    constructor() {\n        this.p = new Point();\n    }\n}\n\nexport {\n    Vec4, Point, CoorList, RegionPoint, Rect, Edge\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/types.ts"],"sourceRoot":""}